<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üïµÔ∏è‚Äç‚ôÇÔ∏è SHADOW STEGO | Invisible Secrets</title>
    <style>
        :root {
            --neon-green: #0f0;
            --neon-red: #f00;
            --dark-bg: #050505;
            --panel-bg: #111;
            --border: #333;
            --text: #ddd;
        }
        
        * { box-sizing: border-box; font-family: 'Courier New', monospace; }
        
        body {
            background-color: var(--dark-bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            overflow-x: hidden;
            background-image: linear-gradient(0deg, transparent 24%, rgba(0, 255, 0, .03) 25%, rgba(0, 255, 0, .03) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .03) 75%, rgba(0, 255, 0, .03) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(0, 255, 0, .03) 25%, rgba(0, 255, 0, .03) 26%, transparent 27%, transparent 74%, rgba(0, 255, 0, .03) 75%, rgba(0, 255, 0, .03) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
        }

        .container { max-width: 900px; margin: 0 auto; }

        /* Glitch Header */
        h1 {
            text-align: center;
            font-size: 3rem;
            color: var(--neon-green);
            text-shadow: 0 0 10px var(--neon-green);
            position: relative;
            animation: glitch 1s infinite alternate;
        }
        
        @keyframes glitch {
            0% { text-shadow: 2px 0 var(--neon-red), -2px 0 blue; }
            100% { text-shadow: -2px 0 var(--neon-red), 2px 0 blue; }
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9rem;
        }

        /* Panels */
        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--neon-green);
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
            position: relative;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; height: 2px;
            background: var(--neon-green);
            box-shadow: 0 0 10px var(--neon-green);
            animation: scan 3s linear infinite;
            opacity: 0.5;
            pointer-events: none;
        }

        @keyframes scan {
            0% { top: 0; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        h2 { color: var(--neon-green); border-bottom: 1px solid #333; padding-bottom: 10px; margin-top: 0; font-size: 1.2rem; }

        /* Controls */
        .drop-zone {
            border: 2px dashed #444;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: 0.3s;
            color: #666;
        }
        .drop-zone:hover, .drop-zone.active {
            border-color: var(--neon-green);
            color: var(--neon-green);
            background: rgba(0, 255, 0, 0.05);
        }

        textarea, input[type="password"] {
            width: 100%;
            background: #000;
            border: 1px solid #333;
            color: var(--neon-green);
            padding: 10px;
            margin-bottom: 15px;
            font-family: monospace;
        }
        
        textarea:focus, input:focus { outline: none; border-color: var(--neon-green); }

        .btn-row { display: flex; gap: 10px; margin-top: 10px; }
        
        button {
            flex: 1;
            padding: 15px;
            background: #000;
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        button:hover {
            background: var(--neon-green);
            color: #000;
            box-shadow: 0 0 20px var(--neon-green);
        }

        button.danger { border-color: var(--neon-red); color: var(--neon-red); }
        button.danger:hover { background: var(--neon-red); color: #000; box-shadow: 0 0 20px var(--neon-red); }

        /* Preview */
        .preview-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
            display: none;
        }
        
        .img-box { text-align: center; }
        .img-box img { max-width: 100%; border: 1px solid #333; }
        .img-label { font-size: 0.8rem; color: #666; margin-bottom: 5px; }

        /* Matrix Rain Canvas */
        #matrix-bg {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            opacity: 0.1;
        }

        /* Status Log */
        #log {
            font-size: 0.9rem;
            color: #666;
            margin-top: 10px;
            height: 20px;
            text-align: center;
        }
        
        .success { color: var(--neon-green) !important; }
        .error { color: var(--neon-red) !important; }

        .tabs { display: flex; margin-bottom: 20px; border-bottom: 1px solid #333; }
        .tab { 
            padding: 10px 20px; 
            cursor: pointer; 
            opacity: 0.5; 
            border: 1px solid transparent; 
            border-bottom: none;
        }
        .tab.active { 
            opacity: 1; 
            border-color: var(--neon-green); 
            color: var(--neon-green);
            background: rgba(0, 255, 0, 0.05);
        }
    </style>
</head>
<body>

<canvas id="matrix-bg"></canvas>

<div class="container">
    <h1>SHADOW_STEGO</h1>
    <div class="subtitle">Verstecke verschl√ºsselte Nachrichten in harmlosen Bildern</div>

    <div class="tabs">
        <div class="tab active" onclick="switchMode('encode')">üîí ENCODE (Verstecken)</div>
        <div class="tab" onclick="switchMode('decode')">üîì DECODE (Auslesen)</div>
    </div>

    <!-- ENCODE SECTION -->
    <div id="section-encode" class="panel">
        <h2>1. TR√ÑGER-BILD W√ÑHLEN</h2>
        <div class="drop-zone" id="drop-encode">
            Drag & Drop Bild hierher<br>
            <small>(JPG, PNG, WebP)</small>
        </div>
        <input type="file" id="file-encode" accept="image/*" style="display:none">

        <div id="encode-controls" style="display:none; margin-top:20px;">
            <h2>2. GEHEIMNIS EINGEBEN</h2>
            <textarea id="secret-text" rows="4" placeholder="Deine geheime Nachricht hier..."></textarea>
            
            <div style="margin-bottom:10px;">
                <input type="password" id="encode-pass" placeholder="Verschl√ºsselungs-Passwort (AES-256)">
            </div>
            
            <div class="btn-row">
                <button onclick="encodeImage()">üîí NACHRICHT VERSTECKEN</button>
            </div>
        </div>
    </div>

    <!-- DECODE SECTION -->
    <div id="section-decode" class="panel" style="display:none;">
        <h2>1. STEGO-BILD W√ÑHLEN</h2>
        <div class="drop-zone" id="drop-decode">
            Drag & Drop das bearbeitete Bild hierher<br>
            <small>(Muss PNG sein!)</small>
        </div>
        <input type="file" id="file-decode" accept="image/*" style="display:none">

        <div id="decode-controls" style="display:none; margin-top:20px;">
            <h2>2. ENTSCHL√úSSELN</h2>
            <input type="password" id="decode-pass" placeholder="Passwort eingeben">
            <div class="btn-row">
                <button onclick="decodeImage()">üîì NACHRICHT AUSLESEN</button>
            </div>
            
            <div id="decoded-result" style="margin-top:20px; padding:15px; border:1px dashed var(--neon-green); display:none;">
                <h3 style="margin-top:0; font-size:0.9rem; color:var(--neon-green);">GEFUNDENE NACHRICHT:</h3>
                <div id="result-text" style="word-break:break-all; color:#fff;"></div>
            </div>
        </div>
    </div>

    <!-- PREVIEW & DOWNLOAD -->
    <div id="result-area" class="panel" style="display:none; border-color:var(--neon-green);">
        <h2>ERGEBNIS</h2>
        <div class="preview-container" style="display:grid;">
            <div class="img-box">
                <div class="img-label">Original</div>
                <img id="preview-original">
            </div>
            <div class="img-box">
                <div class="img-label">Mit versteckter Nachricht</div>
                <img id="preview-stego">
            </div>
        </div>
        <div id="log"></div>
        <div class="btn-row" style="margin-top:20px;">
            <button onclick="downloadStego()" style="background:var(--neon-green); color:#000;">üíæ BILD HERUNTERLADEN</button>
        </div>
        <div style="text-align:center; font-size:0.8rem; color:var(--neon-red); margin-top:10px;">
            ‚ö†Ô∏è WICHTIG: Das Bild muss als PNG gespeichert werden!<br>
            Jede Komprimierung (WhatsApp, Facebook) zerst√∂rt die Nachricht.
        </div>
    </div>

</div>

<script>
    // --- MATRIX BACKGROUND ---
    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const chars = "01";
    const drops = Array(Math.floor(canvas.width/20)).fill(1);
    
    function drawMatrix() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0f0';
        ctx.font = '15px monospace';
        for(let i=0; i<drops.length; i++) {
            const text = chars[Math.floor(Math.random()*chars.length)];
            ctx.fillText(text, i*20, drops[i]*20);
            if(drops[i]*20 > canvas.height && Math.random() > 0.975) drops[i] = 0;
            drops[i]++;
        }
    }
    setInterval(drawMatrix, 50);

    // --- APP LOGIC ---
    let originalImage = null;
    let stegoCanvas = document.createElement('canvas');
    let stegoCtx = stegoCanvas.getContext('2d');

    // UI Switching
    function switchMode(mode) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelector(`.tab[onclick*="${mode}"]`).classList.add('active');
        document.getElementById('section-encode').style.display = mode === 'encode' ? 'block' : 'none';
        document.getElementById('section-decode').style.display = mode === 'decode' ? 'block' : 'none';
        document.getElementById('result-area').style.display = 'none';
    }

    // Drag & Drop
    function setupDrop(zoneId, inputId, callback) {
        const zone = document.getElementById(zoneId);
        const input = document.getElementById(inputId);
        zone.onclick = () => input.click();
        input.onchange = e => callback(e.target.files[0]);
        zone.ondragover = e => { e.preventDefault(); zone.classList.add('active'); };
        zone.ondragleave = () => zone.classList.remove('active');
        zone.ondrop = e => { e.preventDefault(); zone.classList.remove('active'); callback(e.dataTransfer.files[0]); };
    }

    setupDrop('drop-encode', 'file-encode', file => {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                document.getElementById('encode-controls').style.display = 'block';
                document.getElementById('preview-original').src = img.src;
                // Prepare Canvas
                stegoCanvas.width = img.width;
                stegoCanvas.height = img.height;
                stegoCtx.drawImage(img, 0, 0);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });

    setupDrop('drop-decode', 'file-decode', file => {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                stegoCanvas.width = img.width;
                stegoCanvas.height = img.height;
                stegoCtx.drawImage(img, 0, 0);
                document.getElementById('decode-controls').style.display = 'block';
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });

    // --- CRYPTO & STEGANOGRAPHY ---

    // Password Key Derivation
    async function getKey(password) {
        const enc = new TextEncoder();
        const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
        return crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: enc.encode("ShadowStegoSalt"), iterations: 100000, hash: "SHA-256" },
            keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
        );
    }

    async function encodeImage() {
        const text = document.getElementById('secret-text').value;
        const pass = document.getElementById('encode-pass').value;
        if(!text || !pass) return alert("Text und Passwort fehlen!");

        // 1. Encrypt Text
        const key = await getKey(pass);
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encText = new TextEncoder().encode(text);
        const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, key, encText);
        
        // Prepare Data: [IV (12 bytes)] [Length (4 bytes)] [Encrypted Data]
        const dataLength = new Uint32Array([encrypted.byteLength]);
        const buffer = new Uint8Array(iv.length + 4 + encrypted.byteLength);
        buffer.set(iv, 0);
        buffer.set(new Uint8Array(dataLength.buffer), 12);
        buffer.set(new Uint8Array(encrypted), 16);

        // 2. Embed into Image (LSB)
        const imgData = stegoCtx.getImageData(0, 0, stegoCanvas.width, stegoCanvas.height);
        const pixels = imgData.data;
        let dataIndex = 0;
        let bitIndex = 0;

        // Check capacity
        if (buffer.length * 8 > pixels.length / 4 * 3) return alert("Bild ist zu klein f√ºr diese Nachricht!");

        for (let i = 0; i < pixels.length; i += 4) {
            if (dataIndex >= buffer.length) break;

            // Modify R, G, B channels
            for (let j = 0; j < 3; j++) {
                if (dataIndex >= buffer.length) break;

                const bit = (buffer[dataIndex] >> (7 - bitIndex)) & 1;
                // Clear LSB and set new bit
                pixels[i + j] = (pixels[i + j] & 0xFE) | bit;

                bitIndex++;
                if (bitIndex === 8) {
                    bitIndex = 0;
                    dataIndex++;
                }
            }
        }

        stegoCtx.putImageData(imgData, 0, 0);
        
        // Show Result
        const stegoUrl = stegoCanvas.toDataURL('image/png');
        document.getElementById('preview-stego').src = stegoUrl;
        document.getElementById('result-area').style.display = 'block';
        document.getElementById('log').innerText = "‚úÖ Nachricht erfolgreich versteckt!";
        document.getElementById('log').className = "success";
    }

    async function decodeImage() {
        const pass = document.getElementById('decode-pass').value;
        if(!pass) return alert("Passwort fehlt!");

        const imgData = stegoCtx.getImageData(0, 0, stegoCanvas.width, stegoCanvas.height);
        const pixels = imgData.data;
        
        // Extract Bits
        // We need at least IV (12) + Length (4) = 16 bytes to start
        const headerBytes = new Uint8Array(16);
        let byteIndex = 0;
        let bitIndex = 0;
        let pixelIndex = 0;

        function readByte() {
            let byte = 0;
            for(let k=0; k<8; k++) {
                // Find next channel
                const channel = pixelIndex % 3; // 0=R, 1=G, 2=B
                const pixelOffset = Math.floor(pixelIndex / 3) * 4;
                
                const bit = pixels[pixelOffset + channel] & 1;
                byte = (byte << 1) | bit;
                pixelIndex++;
            }
            return byte;
        }

        // Read Header
        for(let i=0; i<16; i++) headerBytes[i] = readByte();

        const iv = headerBytes.slice(0, 12);
        const lengthVal = new Uint32Array(headerBytes.buffer.slice(12, 16))[0];

        // Sanity Check on length
        if(lengthVal > pixels.length || lengthVal === 0) {
            return alert("Keine g√ºltige Nachricht gefunden (oder Bild besch√§digt/komprimiert).");
        }

        // Read Payload
        const payload = new Uint8Array(lengthVal);
        for(let i=0; i<lengthVal; i++) payload[i] = readByte();

        // Decrypt
        try {
            const key = await getKey(pass);
            const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, payload);
            const text = new TextDecoder().decode(decrypted);
            
            document.getElementById('decoded-result').style.display = 'block';
            document.getElementById('result-text').innerText = text;
            alert("Nachricht entschl√ºsselt!");
        } catch(e) {
            alert("Falsches Passwort oder besch√§digte Daten!");
        }
    }

    function downloadStego() {
        const link = document.createElement('a');
        link.download = 'shadow_secret.png';
        link.href = document.getElementById('preview-stego').src;
        link.click();
    }
</script>

</body>
</html>